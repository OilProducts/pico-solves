# #STONKS


I decided to try something noone else has before. I made a bot to automatically trade stonks for me using AI and machine learning. I wouldn't believe you if you told me it's unsecure!

Spoiler alert: It is.

## Starting from nothing

The challenge provides us with the C code that generated the binary to exploit.  It's not very good (he said, about the deliberately bad code).  Since we have source code an easy first step is to run some static analysis on it.  I loaded up the source in CLion which will automatically run clang-tidy.  There are 13 warnings.  Most of them seem harmless but one sticks out

- Format string is not a string literal (potentially insecure)

The relevant code follows: 

```
char *user_buf = malloc(300 + 1);
printf("What is your API token?\n");
scanf("%300s", user_buf);
printf("Buying stonks with token:\n");
printf(user_buf);
```

The important parts:

1. A 301 byte heap allocation is made to a stack allocated pointer.  
2. scanf reads up to 300 bytes into that memory from the user.
3. printf prints the string.

printf is a variadic function, its first argument is the string to print but that string is parsed to determine how many additional arguments there are.  Those arguments are formatted and inserted into the string before it is displayed.

But we control the entirety of that string.

So if one were to craft a string that will cause printf to make some replacements, you could print all sorts of things.  First I tried %s, but it wasn't very helpful.  A key insight is that printf is always going to be called with just one argument, however we can force it to think that it has many arguments.  Each one will get popped off the stack, interpreted according to the format specifier convention, then inserted into what is eventually displayed.  We can tell printf to show us the value of a pointer with %p.  The combination of these things mean that if we feed printf a series of repeating "%p" it will keep popping words from the stack and showing us the value as if it were a memory address.

We have 300 bytes to craft a string, so we can fit a maximum of 150 %p.  It turns out that is way more than enough.

## Fully solved?

Wait...this is only 1 trillionth of a CTF but all CTFs have flags, it's in the name.  And printing stack doesn't help us (directly) unless the flag is on the stack.

I sure am glad that this code was written deliberately bad...the flag was read into the stack a couple functions ago.  The full exploit sequence goes like this.

1. main prompts a choice from you.
2. update the portfolio you own, AI makes it bigger for you
3. buy_stonks fopens up the flag for real. 
4. printf pop pops a painless steal.

Simply claim your token is %p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p\n and printf will pop 24 values from the stack, and display the as pointers like so:

```
b'0x880e4500x804b0000x80489c30xf7f9fd800xffffffff0x10x880c1600xf7fad1100xf7f9fdc7(nil)0x880d1800x20x880e4300x880e4500x6f6369700x7b4654430x306c5f490x345f74350x6d5f6c6c0x306d5f790x5f79336e0x326663310x306131300xff8c007d'
```

Well...that's what I get from python at least, which is only slightly modified from what printf output.  Either way though, theres no obvious flag there, we still need to correct for endianness and then convert that string of hex to something readable.  An easy task with python, simply split on each "0x" to get the hex by itself, then generate bytes from the resulting hex with bytes.fromhex()...then reverse the bytes and print.

voila: b'\x80\xfd\xf9\xf7\xff\xff\xff\xff\x10\xd1\xfa\xf7picoCTF{I_l05t_4ll_my_m0n3y_1cf201a0}\x00\x8c\xff'

picoCTF{I_l05t_4ll_my_m0n3y_1cf201a0}

I'm here all week.